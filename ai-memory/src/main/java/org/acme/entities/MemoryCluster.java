package org.acme.entities;

import java.time.LocalDateTime;

import org.hibernate.annotations.Array;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import io.quarkus.hibernate.orm.panache.PanacheEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;

/**
 * Entity representing a cluster of semantically related memory fragments.
 * 
 * <p>A MemoryCluster groups memory fragments with similar semantic content using
 * the DBSCAN clustering algorithm. Each cluster maintains a prototype vector
 * (centroid) that represents the cluster's semantic center and enables efficient
 * cluster-based retrieval operations.</p>
 * 
 * <p>Key features:</p>
 * <ul>
 *   <li><strong>Prototype Vector:</strong> Centroid embedding that represents the
 *       cluster's semantic center for similarity comparisons</li>
 *   <li><strong>Semantic Theme:</strong> Human-readable description of the cluster's
 *       content generated from member analysis</li>
 *   <li><strong>Dynamic Membership:</strong> Tracks the number of member fragments
 *       and updates as clustering evolves</li>
 *   <li><strong>Temporal Tracking:</strong> Maintains last update timestamp for
 *       cluster evolution analysis</li>
 * </ul>
 * 
 * <p>Clusters enable several advanced memory operations:</p>
 * <ul>
 *   <li>Cluster-aware retrieval for finding related memories</li>
 *   <li>Hierarchical abstraction generation from cluster members</li>
 *   <li>Efficient similarity search using prototype vectors</li>
 *   <li>Semantic navigation and memory exploration</li>
 * </ul>
 * 
 * @author AI Memory System
 * @since 1.0
 */
@Entity
@Table(name = "memory_clusters")
public class MemoryCluster extends PanacheEntity {

    /**
     * Unique identifier for this memory cluster.
     * 
     * <p>This UUID-based identifier is used to link memory fragments to their
     * cluster and is referenced by the clustering service when creating and
     * updating cluster assignments. The cluster ID remains stable across
     * cluster updates unless the cluster is disbanded.</p>
     */
    @Column(name = "cluster_id", unique = true)
    private String clusterId;

    /**
     * Prototype vector representing the semantic center of this cluster.
     * 
     * <p>This 384-dimensional vector is calculated as the centroid (element-wise
     * average) of all member fragment embeddings. The prototype vector serves as:
     * <ul>
     *   <li>Representative embedding for the entire cluster</li>
     *   <li>Basis for cluster-to-query similarity calculations</li>
     *   <li>Input for hierarchical abstraction processes</li>
     *   <li>Reference point for new fragment assignment</li>
     * </ul>
     * 
     * <p>Stored as PostgreSQL VECTOR type to enable efficient similarity operations
     * directly in the database.</p>
     */
    @JdbcTypeCode(SqlTypes.VECTOR)
    @Array(length = 384)
    @Column(name = "prototype_vector")
    private float[] prototypeVector;

    /**
     * Human-readable theme describing the cluster's semantic content.
     * 
     * <p>The theme is automatically generated by analyzing the text content of
     * cluster members and extracting key topics, keywords, and patterns. The
     * theme generation process:
     * <ul>
     *   <li>Extracts meaningful keywords from member text content</li>
     *   <li>Identifies common topic categories (work, travel, personal, etc.)</li>
     *   <li>Filters out stop words and noise</li>
     *   <li>Combines topics and keywords into descriptive phrases</li>
     * </ul>
     * 
     * <p>Example themes: "work, project (software, deadline, payment)" or
     * "travel, personal (europe, vacation, rome)"</p>
     */
    @Column(name = "cluster_theme", columnDefinition = "TEXT")
    private String theme;

    /**
     * Number of memory fragments currently assigned to this cluster.
     * 
     * <p>This count is maintained by the clustering service and reflects the
     * current cluster size. Used for:
     * <ul>
     *   <li>Cluster significance evaluation</li>
     *   <li>Abstraction generation decisions</li>
     *   <li>Performance optimization (large cluster handling)</li>
     *   <li>Monitoring and analytics</li>
     * </ul>
     * 
     * <p>The count is updated when fragments are added to or removed from
     * the cluster through re-clustering operations.</p>
     */
    @Column(name = "member_count")
    private Integer memberCount;

    /**
     * Timestamp when this cluster was last updated.
     * 
     * <p>Updated whenever the cluster undergoes changes such as:
     * <ul>
     *   <li>New fragment assignments</li>
     *   <li>Prototype vector recalculation</li>
     *   <li>Theme regeneration</li>
     *   <li>Member count updates</li>
     * </ul>
     * 
     * <p>Used for tracking cluster evolution, determining cluster stability,
     * and scheduling abstraction generation for mature clusters.</p>
     */
    @Column(name = "last_updated")
    private LocalDateTime lastUpdated;

    // Getter and setter methods with comprehensive documentation

    /**
     * Gets the unique cluster identifier.
     * 
     * @return the cluster ID string
     */
    public String getClusterId() {
        return clusterId;
    }

    /**
     * Sets the unique cluster identifier.
     * 
     * @param clusterId the cluster ID to set
     */
    public void setClusterId(String clusterId) {
        this.clusterId = clusterId;
    }

    /**
     * Gets the prototype vector representing the cluster's semantic center.
     * 
     * @return the 384-dimensional prototype vector array
     */
    public float[] getPrototypeVector() {
        return prototypeVector;
    }

    /**
     * Sets the prototype vector for this cluster.
     * 
     * @param prototypeVector the 384-dimensional prototype vector array
     */
    public void setPrototypeVector(float[] prototypeVector) {
        this.prototypeVector = prototypeVector;
    }

    /**
     * Gets the human-readable theme describing the cluster's content.
     * 
     * @return the cluster theme description
     */
    public String getTheme() {
        return theme;
    }

    /**
     * Sets the human-readable theme for this cluster.
     * 
     * @param theme the cluster theme description to set
     */
    public void setTheme(String theme) {
        this.theme = theme;
    }

    /**
     * Gets the number of memory fragments in this cluster.
     * 
     * @return the member count
     */
    public Integer getMemberCount() {
        return memberCount;
    }

    /**
     * Sets the number of memory fragments in this cluster.
     * 
     * @param memberCount the member count to set
     */
    public void setMemberCount(Integer memberCount) {
        this.memberCount = memberCount;
    }

    /**
     * Gets the timestamp when this cluster was last updated.
     * 
     * @return the last updated timestamp
     */
    public LocalDateTime getLastUpdated() {
        return lastUpdated;
    }

    /**
     * Sets the timestamp when this cluster was last updated.
     * 
     * @param lastUpdated the last updated timestamp to set
     */
    public void setLastUpdated(LocalDateTime lastUpdated) {
        this.lastUpdated = lastUpdated;
    }
}
